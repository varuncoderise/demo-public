name: Release

on:
  pull_request:
    types: [closed]
    branches:
      - main

permissions:
  contents: read
  pull-requests: read

env:
  DEFAULT_TAG: v1.0.0
  TIMEZONE: Asia/Kolkata
  BOT_NAME: coderiseio-bot
  BOT_EMAIL: coderiseio@bot.com
  REPO: ${{ github.repository }}

jobs:
  release:
    runs-on: ubuntu-latest
    if: github.event.pull_request.merged == true
    steps:
      # Checkout repository
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: main
          token: ${{ secrets.PAT_TOKEN }}

      # Calculate 3-Digit Version
      - name: Calculate 3-Digit Version
        id: version
        env:
          GH_TOKEN: ${{ secrets.PAT_TOKEN }}
        run: |
          echo "Fetching tags"
          git fetch --tags --force
          
          # Fetch latest valid tag matching vX.Y.Z for changelog range only
          LAST_TAG=$(git tag --list 'v[0-9]*.[0-9]*.[0-9]*' --sort=-v:refname | head -n1)
          if [[ -z "$LAST_TAG" ]]; then
            LAST_TAG="${{ env.DEFAULT_TAG }}"
            echo "No valid tags found. Using DEFAULT_TAG for range: $LAST_TAG"
          fi
          echo "Latest tag for range: $LAST_TAG"

          # Validate LAST_TAG format
          if [[ ! "$LAST_TAG" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "Invalid LAST_TAG format: $LAST_TAG. Using DEFAULT_TAG for range."
            LAST_TAG="${{ env.DEFAULT_TAG }}"
          fi

          # Set commit range for changelog
          if git rev-parse "$LAST_TAG" >/dev/null 2>&1; then
            COMMIT_RANGE="${LAST_TAG}..HEAD"
          else
            COMMIT_RANGE="HEAD"
          fi
          echo "Commit range: $COMMIT_RANGE"
          echo "COMMIT_RANGE=$COMMIT_RANGE" >> $GITHUB_ENV

          # --- Capture merge commit BEFORE any changes ---
          MERGE_COMMIT_SHA=$(git rev-parse HEAD)
          SHORT_MERGE_SHA="${MERGE_COMMIT_SHA:0:7}"
          echo "MERGE_COMMIT_SHA=$MERGE_COMMIT_SHA" >> $GITHUB_ENV
          echo "SHORT_MERGE_SHA=$SHORT_MERGE_SHA" >> $GITHUB_ENV
          echo "TAG_ON_COMMIT=$MERGE_COMMIT_SHA" >> $GITHUB_ENV

          # --- Base version on file (servv.php) ---
          CURRENT_VERSION=$(grep -i "Version:" servv.php | head -n1 | sed -E 's/.*Version:[[:space:]]*([0-9]+\.[0-9]+\.[0-9]+).*/\1/')
          echo "Current version in PHP file: ${CURRENT_VERSION:-none}"

          CURRENT_STABLE=$(grep -i "Stable tag:" readme.txt | head -n1 | sed -E 's/.*Stable tag:[[:space:]]*([0-9]+\.[0-9]+\.[0-9]+).*/\1/')
          echo "Current Stable tag in readme.txt: ${CURRENT_STABLE:-none}"

          # Parse from file or fallback to tag
          if [[ "$CURRENT_VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            VERSION="$CURRENT_VERSION"
            echo "Using file version: $VERSION"
          else
            VERSION="${LAST_TAG#v}"
            echo "File version invalid, fallback to tag: $VERSION"
            if [[ ! "$VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
              VERSION="1.0.0"
              echo "Tag invalid too, using default: $VERSION"
            fi
          fi

          IFS='.' read -r MAJOR MINOR PATCH <<< "$VERSION"
          MAJOR=${MAJOR:-1}
          MINOR=${MINOR:-0}
          PATCH=${PATCH:-0}
          echo "Parsed version: MAJOR=$MAJOR, MINOR=$MINOR, PATCH=$PATCH"

          # Validate components
          if ! [[ "$MAJOR" =~ ^[0-9]+$ && "$MINOR" =~ ^[0-9]+$ && "$PATCH" =~ ^[0-9]+$ ]]; then
            echo "Invalid components after parse: Using defaults."
            MAJOR=1; MINOR=0; PATCH=0
          fi

          # --- Determine release type and version ---
          PR_NUMBER=${{ github.event.pull_request.number }}
          LABELS=$(GH_TOKEN=${{ secrets.PAT_TOKEN }} gh pr view $PR_NUMBER --json labels --jq '.labels[].name')
          echo "PR labels: $LABELS"

          if echo "$LABELS" | grep -q "^release:major$"; then
            RELEASE_TYPE="major"; MAJOR=$((MAJOR + 1)); MINOR=0; PATCH=0; CHANGELOG_SECTION="Feature Release"; BREAKING_CHANGES="true"
          elif echo "$LABELS" | grep -q "^release:minor$"; then
            RELEASE_TYPE="minor"; MINOR=$((MINOR + 1)); PATCH=0; CHANGELOG_SECTION="Feature Release"; BREAKING_CHANGES="false"
          elif echo "$LABELS" | grep -q "^release:patch$"; then
            RELEASE_TYPE="patch"; PATCH=$((PATCH + 1)); CHANGELOG_SECTION="Maintenance Release"; BREAKING_CHANGES="false"
          elif echo "$LABELS" | grep -q "^release:hotfix$"; then
            RELEASE_TYPE="hotfix"; PATCH=$((PATCH + 1)); CHANGELOG_SECTION="Hotfix Release"; BREAKING_CHANGES="false"
          else
            RELEASE_TYPE="none"; CHANGELOG_SECTION="Maintenance Release"; BREAKING_CHANGES="false"
          fi

          echo "Release type: $RELEASE_TYPE"
          echo "RELEASE_TYPE=$RELEASE_TYPE" >> $GITHUB_ENV
          echo "BREAKING_CHANGES=$BREAKING_CHANGES" >> $GITHUB_ENV

          if [ "$RELEASE_TYPE" != "none" ]; then
            NEW_VERSION="v$MAJOR.$MINOR.$PATCH"
            BARE_VERSION="$MAJOR.$MINOR.$PATCH"

            # Final validation
            if [[ ! "$NEW_VERSION" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
              echo "Invalid NEW_VERSION: $NEW_VERSION. Defaulting."
              NEW_VERSION="v1.0.0"
              BARE_VERSION="1.0.0"
            fi

            echo "NEW_VERSION=$NEW_VERSION" >> $GITHUB_ENV
            echo "BARE_VERSION=$BARE_VERSION" >> $GITHUB_ENV
            echo "CHANGELOG_SECTION=$CHANGELOG_SECTION" >> $GITHUB_ENV

            # --- Update files only if needed ---
            CHANGED=false
            if [ "$CURRENT_VERSION" != "$BARE_VERSION" ]; then
              sed -i "s/Version:[[:space:]]*.*/Version: $BARE_VERSION/" servv.php
              CHANGED=true
            fi

            if [ "$CURRENT_STABLE" != "$BARE_VERSION" ]; then
              if grep -q "Stable tag:" readme.txt; then
                sed -i "s/Stable tag:[[:space:]]*.*/Stable tag: $BARE_VERSION/" readme.txt
              else
                echo "Stable tag: $BARE_VERSION" >> readme.txt
              fi
              CHANGED=true
            fi

            if [ "$CHANGED" = true ]; then
              git config user.name "${{ env.BOT_NAME }}"
              git config user.email "${{ env.BOT_EMAIL }}"
              git add servv.php readme.txt
              git commit -m "Update version and stable tag to $BARE_VERSION" || echo "Commit failed, but continuing"
              git remote set-url origin https://x-access-token:${{ secrets.PAT_TOKEN }}@github.com/${{ env.REPO }}.git
              git push origin main || echo "Push failed, but continuing"
              echo "Updated files to $BARE_VERSION"
            else
              echo "Files already at $BARE_VERSION"
            fi
          else
            echo "No release (none type)"
            echo "NEW_VERSION=" >> $GITHUB_ENV
            echo "BARE_VERSION=" >> $GITHUB_ENV
          fi

          # --- Collect commits ---
          mapfile -t COMMIT_DETAILS < <(git log "$COMMIT_RANGE" --no-merges --pretty=format:"%H%n%s%n%b%n---COMMIT-END---" || echo "")
          
          BREAKING_MD=""
          OTHER_MD=""

          i=0
          while [ $i -lt ${#COMMIT_DETAILS[@]} ]; do
            SHA="${COMMIT_DETAILS[$i]}"; ((i++))
            SUBJECT="${COMMIT_DETAILS[$i]}"; ((i++))
            
            if echo "$SUBJECT" | grep -q "Update version"; then
              while [ $i -lt ${#COMMIT_DETAILS[@]} ] && [ "${COMMIT_DETAILS[$i]}" != "---COMMIT-END---" ]; do ((i++)); done
              ((i++))
              continue
            fi

            BODY=""
            while [ $i -lt ${#COMMIT_DETAILS[@]} ] && [ "${COMMIT_DETAILS[$i]}" != "---COMMIT-END---" ]; do
              BODY="$BODY${COMMIT_DETAILS[$i]}\n"
              ((i++))
            done
            ((i++))

            IS_BREAKING=false
            if echo "$SUBJECT" | grep -q "!:" || echo "$BODY" | grep -q "^BREAKING CHANGE:"; then
              IS_BREAKING=true
            fi

            CLEAN_SUBJECT=$(echo "$SUBJECT" | sed -E 's/^[a-z]+(\([a-z]+\))?: //')
            SHORT_SHA="${SHA:0:7}"
            FORMATTED="- $CLEAN_SUBJECT [$SHORT_SHA](https://github.com/${{ env.REPO }}/commit/$SHA)"

            if [ -n "$BODY" ]; then
              while IFS= read -r line; do
                if [ -n "$line" ] && ! echo "$line" | grep -q "^BREAKING CHANGE:"; then
                  FORMATTED="$FORMATTED\n  - $line"
                fi
              done <<< "$BODY"
            fi

            if [ "$IS_BREAKING" = true ]; then
              BREAKING_MD="$BREAKING_MD\n$FORMATTED"
            else
              OTHER_MD="$OTHER_MD\n$FORMATTED"
            fi
          done

          BREAKING_MD=$(echo -e "$BREAKING_MD" | sed '/^$/d' | tail -c +2)
          OTHER_MD=$(echo -e "$OTHER_MD" | sed '/^$/d' | tail -c +2)

          echo "BREAKING_COMMITS<<EOF" >> $GITHUB_ENV
          echo "$BREAKING_MD" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV
          echo "OTHER_COMMITS<<EOF" >> $GITHUB_ENV
          echo "$OTHER_MD" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV

      - name: Generate Changelog
        if: env.NEW_VERSION != ''
        run: |
          echo "Generating changelog for ${{ env.NEW_VERSION }}"
          {
            echo "# ${{ env.NEW_VERSION }}"
            echo ""
            echo "${{ env.BARE_VERSION }} ($(TZ=${{ env.TIMEZONE }} date +%Y-%m-%d))"
            echo ""
            if [ "${{ env.BREAKING_CHANGES }}" = "true" ] && [ -n "${{ env.BREAKING_COMMITS }}" ]; then
              echo "BREAKING CHANGES"
              echo ""
              echo "${{ env.BREAKING_COMMITS }}"
              echo ""
            fi
            echo "${{ env.CHANGELOG_SECTION }}"
            echo ""
            if [ -n "${{ env.OTHER_COMMITS }}" ]; then
              echo "${{ env.OTHER_COMMITS }}"
            else
              echo "- No changes recorded"
            fi
          } > changelog_temp.md

          if [[ -f CHANGELOG.md ]]; then
            echo "" >> changelog_temp.md
            cat CHANGELOG.md >> changelog_temp.md
          fi
          mv changelog_temp.md CHANGELOG.md

          git add CHANGELOG.md || echo "No changelog changes"
          git config user.name "${{ env.BOT_NAME }}"
          git config user.email "${{ env.BOT_EMAIL }}"
          git commit -m "update changelog for ${{ env.NEW_VERSION }}" || echo "Commit failed, continuing"
          git remote set-url origin https://x-access-token:${{ secrets.PAT_TOKEN }}@github.com/${{ env.REPO }}.git
          git push origin main || echo "Push failed, continuing"

      - name: Create Source Code Zip
        if: env.NEW_VERSION != ''
        run: |
          git checkout ${{ env.MERGE_COMMIT_SHA }}
          REPO_NAME="servvai-event-booking"
          ZIP_NAME="${REPO_NAME}-${{ env.NEW_VERSION }}.zip"
          git archive --format=zip --output="${ZIP_NAME}" HEAD $(git ls-files | grep -v '^\.' | grep -v '/\.')
          echo "ZIP_NAME=$ZIP_NAME" >> $GITHUB_ENV

      - name: Debug Zip Contents
        if: env.NEW_VERSION != ''
        run: unzip -l "${{ env.ZIP_NAME }}"

      - name: Create Tag and Release
        if: env.NEW_VERSION != ''
        env:
          GH_TOKEN: ${{ secrets.PAT_TOKEN }}
        run: |
          echo "Tagging ${{ env.NEW_VERSION }} on ${{ env.TAG_ON_COMMIT }}"
          git tag -a "${{ env.NEW_VERSION }}" ${{ env.TAG_ON_COMMIT }} -m "release ${{ env.NEW_VERSION }}" || echo "Tag failed"
          git remote set-url origin https://x-access-token:${{ secrets.PAT_TOKEN }}@github.com/${{ env.REPO }}.git
          git push origin "${{ env.NEW_VERSION }}" || echo "Tag push failed"

          {
            echo "# ${{ env.NEW_VERSION }}"
            echo ""
            echo "${{ env.BARE_VERSION }} ($(TZ=${{ env.TIMEZONE }} date +%Y-%m-%d))"
            echo ""
            if [ "${{ env.BREAKING_CHANGES }}" = "true" ] && [ -n "${{ env.BREAKING_COMMITS }}" ]; then
              echo "BREAKING CHANGES"
              echo ""
              echo "${{ env.BREAKING_COMMITS }}"
              echo ""
            fi
            echo "${{ env.CHANGELOG_SECTION }}"
            echo ""
            if [ -n "${{ env.OTHER_COMMITS }}" ]; then
              echo "${{ env.OTHER_COMMITS }}"
            else
              echo "- No changes"
            fi
          } > release_notes.md

          gh release create "${{ env.NEW_VERSION }}" \
            --title "Release: ${{ env.NEW_VERSION }}" \
            --notes-file release_notes.md \
            --target ${{ env.TAG_ON_COMMIT }} \
            "${{ env.ZIP_NAME }}#Clean Package" || echo "Release create failed"